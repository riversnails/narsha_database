###############################################################################
#                                                                             #
#                                                       12/Jun/2012  13:52:18 #
# IAR ANSI C/C++ Compiler V6.30.8.23653/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Wk.Src\Mango-M32F2\Libraries\STM32F2xx_StdPeriph_Driv #
#                    er\src\stm32f2xx_usart.c                                 #
#    Command line =  D:\Wk.Src\Mango-M32F2\Libraries\STM32F2xx_StdPeriph_Driv #
#                    er\src\stm32f2xx_usart.c -D USE_STDPERIPH_DRIVER -D      #
#                    USB_TEST -lcN D:\Wk.Src\Mango-M32F2\project\EWARM-USB-De #
#                    vice-VCP\Debug\List\ -o D:\Wk.Src\Mango-M32F2\project\EW #
#                    ARM-USB-Device-VCP\Debug\Obj\ --debug --endian=little    #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Evaluation\arm\INC\c\DLib_Config_Full.h" -I              #
#                    D:\Wk.Src\Mango-M32F2\project\EWARM-USB-Device-VCP\..\.. #
#                    \Libraries\CMSIS\Device\ST\STM32F2xx\Include\ -I         #
#                    D:\Wk.Src\Mango-M32F2\project\EWARM-USB-Device-VCP\..\.. #
#                    \Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I            #
#                    D:\Wk.Src\Mango-M32F2\project\EWARM-USB-Device-VCP\..\.. #
#                    \src\ -I D:\Wk.Src\Mango-M32F2\project\EWARM-USB-Device- #
#                    VCP\..\..\src\USB-Device-VCP\inc\ -I                     #
#                    D:\Wk.Src\Mango-M32F2\project\EWARM-USB-Device-VCP\..\.. #
#                    \Libraries\STM32_USB_OTG_Driver\inc\ -I                  #
#                    D:\Wk.Src\Mango-M32F2\project\EWARM-USB-Device-VCP\..\.. #
#                    \Libraries\STM32_USB_Device_Library\Core\inc\ -I         #
#                    D:\Wk.Src\Mango-M32F2\project\EWARM-USB-Device-VCP\..\.. #
#                    \Libraries\STM32_USB_Device_Library\Class\cdc\inc\ -Ohs  #
#                    -I "C:\Program Files\IAR Systems\Embedded Workbench 6.0  #
#                    Evaluation\arm\CMSIS\Include\"                           #
#    List file    =  D:\Wk.Src\Mango-M32F2\project\EWARM-USB-Device-VCP\Debug #
#                    \List\stm32f2xx_usart.lst                                #
#    Object file  =  D:\Wk.Src\Mango-M32F2\project\EWARM-USB-Device-VCP\Debug #
#                    \Obj\stm32f2xx_usart.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\Wk.Src\Mango-M32F2\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.1.2
      6            * @date    05-March-2012 
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           - Initialization and Configuration
     11            *           - Data transfers
     12            *           - Multi-Processor Communication
     13            *           - LIN mode
     14            *           - Half-duplex mode
     15            *           - Smartcard mode
     16            *           - IrDA mode
     17            *           - DMA transfers management
     18            *           - Interrupts and flags management 
     19            *           
     20            *  @verbatim
     21            *      
     22            *          ===================================================================
     23            *                                 How to use this driver
     24            *          ===================================================================
     25            *          1. Enable peripheral clock using the follwoing functions
     26            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
     27            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or UART5.
     28            *
     29            *          2.  According to the USART mode, enable the GPIO clocks using 
     30            *              RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
     31            *              or/and SCLK). 
     32            *
     33            *          3. Peripheral's alternate function: 
     34            *                 - Connect the pin to the desired peripherals' Alternate 
     35            *                   Function (AF) using GPIO_PinAFConfig() function
     36            *                 - Configure the desired pin in alternate function by:
     37            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38            *                 - Select the type, pull-up/pull-down and output speed via 
     39            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     40            *                 - Call GPIO_Init() function
     41            *        
     42            *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
     43            *             flow control and Mode(Receiver/Transmitter) using the USART_Init()
     44            *             function.
     45            *
     46            *          5. For synchronous mode, enable the clock and program the polarity,
     47            *             phase and last bit using the USART_ClockInit() function.
     48            *
     49            *          5. Enable the NVIC and the corresponding interrupt using the function 
     50            *             USART_ITConfig() if you need to use interrupt mode. 
     51            *
     52            *          6. When using the DMA mode 
     53            *                   - Configure the DMA using DMA_Init() function
     54            *                   - Active the needed channel Request using USART_DMACmd() function
     55            * 
     56            *          7. Enable the USART using the USART_Cmd() function.
     57            * 
     58            *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     59            *
     60            *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
     61            *          for more details
     62            *          
     63            *          In order to reach higher communication baudrates, it is possible to
     64            *          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
     65            *          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
     66            *          and before calling the function USART_Init().
     67            *          
     68            *  @endverbatim
     69            *        
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     74            *
     75            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     76            * You may not use this file except in compliance with the License.
     77            * You may obtain a copy of the License at:
     78            *
     79            *        http://www.st.com/software_license_agreement_liberty_v2
     80            *
     81            * Unless required by applicable law or agreed to in writing, software 
     82            * distributed under the License is distributed on an "AS IS" BASIS, 
     83            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     84            * See the License for the specific language governing permissions and
     85            * limitations under the License.
     86            *
     87            ******************************************************************************
     88            */
     89          
     90          /* Includes ------------------------------------------------------------------*/
     91          #include "stm32f2xx_usart.h"
     92          #include "stm32f2xx_rcc.h"
     93          
     94          /** @addtogroup STM32F2xx_StdPeriph_Driver
     95            * @{
     96            */
     97          
     98          /** @defgroup USART 
     99            * @brief USART driver modules
    100            * @{
    101            */
    102          
    103          /* Private typedef -----------------------------------------------------------*/
    104          /* Private define ------------------------------------------------------------*/
    105          
    106          /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
    107          #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
    108                                                        USART_CR1_PS | USART_CR1_TE | \
    109                                                        USART_CR1_RE))
    110          
    111          /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
    112          #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
    113                                                        USART_CR2_CPHA | USART_CR2_LBCL))
    114          
    115          /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
    116          #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
    117          
    118          /*!< USART Interrupts mask */
    119          #define IT_MASK                   ((uint16_t)0x001F)
    120          
    121          /* Private macro -------------------------------------------------------------*/
    122          /* Private variables ---------------------------------------------------------*/
    123          /* Private function prototypes -----------------------------------------------*/
    124          /* Private functions ---------------------------------------------------------*/
    125          
    126          /** @defgroup USART_Private_Functions
    127            * @{
    128            */
    129          
    130          /** @defgroup USART_Group1 Initialization and Configuration functions
    131           *  @brief   Initialization and Configuration functions 
    132           *
    133          @verbatim   
    134           ===============================================================================
    135                            Initialization and Configuration functions
    136           ===============================================================================  
    137          
    138            This subsection provides a set of functions allowing to initialize the USART 
    139            in asynchronous and in synchronous modes.
    140             - For the asynchronous mode only these parameters can be configured: 
    141                  - Baud Rate
    142                  - Word Length 
    143                  - Stop Bit
    144                  - Parity: If the parity is enabled, then the MSB bit of the data written
    145                    in the data register is transmitted but is changed by the parity bit.
    146                    Depending on the frame length defined by the M bit (8-bits or 9-bits),
    147                    the possible USART frame formats are as listed in the following table:
    148             +-------------------------------------------------------------+     
    149             |   M bit |  PCE bit  |            USART frame                |
    150             |---------------------|---------------------------------------|             
    151             |    0    |    0      |    | SB | 8 bit data | STB |          |
    152             |---------|-----------|---------------------------------------|  
    153             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    154             |---------|-----------|---------------------------------------|  
    155             |    1    |    0      |    | SB | 9 bit data | STB |          |
    156             |---------|-----------|---------------------------------------|  
    157             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    158             +-------------------------------------------------------------+            
    159                  - Hardware flow control
    160                  - Receiver/transmitter modes
    161          
    162            The USART_Init() function follows the USART  asynchronous configuration procedure
    163            (details for the procedure are available in reference manual (RM0033)).
    164          
    165            - For the synchronous mode in addition to the asynchronous mode parameters these 
    166              parameters should be also configured:
    167                  - USART Clock Enabled
    168                  - USART polarity
    169                  - USART phase
    170                  - USART LastBit
    171            
    172            These parameters can be configured using the USART_ClockInit() function.
    173          
    174          @endverbatim
    175            * @{
    176            */
    177            
    178          /**
    179            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    180            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    181            *         UART peripheral.
    182            * @retval None
    183            */
    184          void USART_DeInit(USART_TypeDef* USARTx)
    185          {
    186            /* Check the parameters */
    187            assert_param(IS_USART_ALL_PERIPH(USARTx));
    188          
    189            if (USARTx == USART1)
    190            {
    191              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    192              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
    193            }
    194            else if (USARTx == USART2)
    195            {
    196              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    197              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
    198            }
    199            else if (USARTx == USART3)
    200            {
    201              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    202              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
    203            }    
    204            else if (USARTx == UART4)
    205            {
    206              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
    207              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
    208            }
    209            else if (USARTx == UART5)
    210            {
    211              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
    212              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    213            }     
    214            else
    215            {
    216              if (USARTx == USART6)
    217              { 
    218                RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
    219                RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    220              }
    221            }
    222          }
    223          
    224          /**
    225            * @brief  Initializes the USARTx peripheral according to the specified
    226            *         parameters in the USART_InitStruct .
    227            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    228            *         UART peripheral.
    229            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
    230            *         the configuration information for the specified USART peripheral.
    231            * @retval None
    232            */
    233          void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
    234          {
    235            uint32_t tmpreg = 0x00, apbclock = 0x00;
    236            uint32_t integerdivider = 0x00;
    237            uint32_t fractionaldivider = 0x00;
    238            RCC_ClocksTypeDef RCC_ClocksStatus;
    239          
    240            /* Check the parameters */
    241            assert_param(IS_USART_ALL_PERIPH(USARTx));
    242            assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
    243            assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
    244            assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
    245            assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
    246            assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
    247            assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
    248          
    249            /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
    250            if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
    251            {
    252              assert_param(IS_USART_1236_PERIPH(USARTx));
    253            }
    254          
    255          /*---------------------------- USART CR2 Configuration -----------------------*/
    256            tmpreg = USARTx->CR2;
    257          
    258            /* Clear STOP[13:12] bits */
    259            tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
    260          
    261            /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
    262                Set STOP[13:12] bits according to USART_StopBits value */
    263            tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
    264            
    265            /* Write to USART CR2 */
    266            USARTx->CR2 = (uint16_t)tmpreg;
    267          
    268          /*---------------------------- USART CR1 Configuration -----------------------*/
    269            tmpreg = USARTx->CR1;
    270          
    271            /* Clear M, PCE, PS, TE and RE bits */
    272            tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
    273          
    274            /* Configure the USART Word Length, Parity and mode: 
    275               Set the M bits according to USART_WordLength value 
    276               Set PCE and PS bits according to USART_Parity value
    277               Set TE and RE bits according to USART_Mode value */
    278            tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
    279                      USART_InitStruct->USART_Mode;
    280          
    281            /* Write to USART CR1 */
    282            USARTx->CR1 = (uint16_t)tmpreg;
    283          
    284          /*---------------------------- USART CR3 Configuration -----------------------*/  
    285            tmpreg = USARTx->CR3;
    286          
    287            /* Clear CTSE and RTSE bits */
    288            tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
    289          
    290            /* Configure the USART HFC : 
    291                Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
    292            tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
    293          
    294            /* Write to USART CR3 */
    295            USARTx->CR3 = (uint16_t)tmpreg;
    296          
    297          /*---------------------------- USART BRR Configuration -----------------------*/
    298            /* Configure the USART Baud Rate */
    299            RCC_GetClocksFreq(&RCC_ClocksStatus);
    300          
    301            if ((USARTx == USART1) || (USARTx == USART6))
    302            {
    303              apbclock = RCC_ClocksStatus.PCLK2_Frequency;
    304            }
    305            else
    306            {
    307              apbclock = RCC_ClocksStatus.PCLK1_Frequency;
    308            }
    309            
    310            /* Determine the integer part */
    311            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
    312            {
    313              /* Integer part computing in case Oversampling mode is 8 Samples */
    314              integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
    315            }
    316            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    317            {
    318              /* Integer part computing in case Oversampling mode is 16 Samples */
    319              integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
    320            }
    321            tmpreg = (integerdivider / 100) << 4;
    322          
    323            /* Determine the fractional part */
    324            fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
    325          
    326            /* Implement the fractional part in the register */
    327            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
    328            {
    329              tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
    330            }
    331            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    332            {
    333              tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
    334            }
    335            
    336            /* Write to USART BRR register */
    337            USARTx->BRR = (uint16_t)tmpreg;
    338          }
    339          
    340          /**
    341            * @brief  Fills each USART_InitStruct member with its default value.
    342            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
    343            *         be initialized.
    344            * @retval None
    345            */
    346          void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
    347          {
    348            /* USART_InitStruct members default value */
    349            USART_InitStruct->USART_BaudRate = 9600;
    350            USART_InitStruct->USART_WordLength = USART_WordLength_8b;
    351            USART_InitStruct->USART_StopBits = USART_StopBits_1;
    352            USART_InitStruct->USART_Parity = USART_Parity_No ;
    353            USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    354            USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
    355          }
    356          
    357          /**
    358            * @brief  Initializes the USARTx peripheral Clock according to the 
    359            *         specified parameters in the USART_ClockInitStruct .
    360            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
    361            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
    362            *         contains the configuration information for the specified  USART peripheral.
    363            * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
    364            * @retval None
    365            */
    366          void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
    367          {
    368            uint32_t tmpreg = 0x00;
    369            /* Check the parameters */
    370            assert_param(IS_USART_1236_PERIPH(USARTx));
    371            assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
    372            assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
    373            assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
    374            assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
    375            
    376          /*---------------------------- USART CR2 Configuration -----------------------*/
    377            tmpreg = USARTx->CR2;
    378            /* Clear CLKEN, CPOL, CPHA and LBCL bits */
    379            tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
    380            /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
    381            /* Set CLKEN bit according to USART_Clock value */
    382            /* Set CPOL bit according to USART_CPOL value */
    383            /* Set CPHA bit according to USART_CPHA value */
    384            /* Set LBCL bit according to USART_LastBit value */
    385            tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
    386                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
    387            /* Write to USART CR2 */
    388            USARTx->CR2 = (uint16_t)tmpreg;
    389          }
    390          
    391          /**
    392            * @brief  Fills each USART_ClockInitStruct member with its default value.
    393            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
    394            *         which will be initialized.
    395            * @retval None
    396            */
    397          void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
    398          {
    399            /* USART_ClockInitStruct members default value */
    400            USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
    401            USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
    402            USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
    403            USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
    404          }
    405          
    406          /**
    407            * @brief  Enables or disables the specified USART peripheral.
    408            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    409            *         UART peripheral.
    410            * @param  NewState: new state of the USARTx peripheral.
    411            *          This parameter can be: ENABLE or DISABLE.
    412            * @retval None
    413            */
    414          void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    415          {
    416            /* Check the parameters */
    417            assert_param(IS_USART_ALL_PERIPH(USARTx));
    418            assert_param(IS_FUNCTIONAL_STATE(NewState));
    419            
    420            if (NewState != DISABLE)
    421            {
    422              /* Enable the selected USART by setting the UE bit in the CR1 register */
    423              USARTx->CR1 |= USART_CR1_UE;
    424            }
    425            else
    426            {
    427              /* Disable the selected USART by clearing the UE bit in the CR1 register */
    428              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
    429            }
    430          }
    431          
    432          /**
    433            * @brief  Sets the system clock prescaler.
    434            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    435            *         UART peripheral.
    436            * @param  USART_Prescaler: specifies the prescaler clock. 
    437            * @note   The function is used for IrDA mode with UART4 and UART5.   
    438            * @retval None
    439            */
    440          void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
    441          { 
    442            /* Check the parameters */
    443            assert_param(IS_USART_ALL_PERIPH(USARTx));
    444            
    445            /* Clear the USART prescaler */
    446            USARTx->GTPR &= USART_GTPR_GT;
    447            /* Set the USART prescaler */
    448            USARTx->GTPR |= USART_Prescaler;
    449          }
    450          
    451          /**
    452            * @brief  Enables or disables the USART's 8x oversampling mode.
    453            * @note   This function has to be called before calling USART_Init() function
    454            *         in order to have correct baudrate Divider value.
    455            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    456            *         UART peripheral.
    457            * @param  NewState: new state of the USART 8x oversampling mode.
    458            *          This parameter can be: ENABLE or DISABLE.
    459            * @retval None
    460            */
    461          void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    462          {
    463            /* Check the parameters */
    464            assert_param(IS_USART_ALL_PERIPH(USARTx));
    465            assert_param(IS_FUNCTIONAL_STATE(NewState));
    466            
    467            if (NewState != DISABLE)
    468            {
    469              /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    470              USARTx->CR1 |= USART_CR1_OVER8;
    471            }
    472            else
    473            {
    474              /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    475              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
    476            }
    477          }  
    478          
    479          /**
    480            * @brief  Enables or disables the USART's one bit sampling method.
    481            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    482            *         UART peripheral.
    483            * @param  NewState: new state of the USART one bit sampling method.
    484            *          This parameter can be: ENABLE or DISABLE.
    485            * @retval None
    486            */
    487          void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    488          {
    489            /* Check the parameters */
    490            assert_param(IS_USART_ALL_PERIPH(USARTx));
    491            assert_param(IS_FUNCTIONAL_STATE(NewState));
    492            
    493            if (NewState != DISABLE)
    494            {
    495              /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    496              USARTx->CR3 |= USART_CR3_ONEBIT;
    497            }
    498            else
    499            {
    500              /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    501              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
    502            }
    503          }
    504          
    505          /**
    506            * @}
    507            */
    508          
    509          /** @defgroup USART_Group2 Data transfers functions
    510           *  @brief   Data transfers functions 
    511           *
    512          @verbatim   
    513           ===============================================================================
    514                                      Data transfers functions
    515           ===============================================================================  
    516          
    517            This subsection provides a set of functions allowing to manage the USART data 
    518            transfers.
    519            
    520            During an USART reception, data shifts in least significant bit first through 
    521            the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
    522            between the internal bus and the received shift register.
    523          
    524            When a transmission is taking place, a write instruction to the USART_DR register 
    525            stores the data in the TDR register and which is copied in the shift register 
    526            at the end of the current transmission.
    527          
    528            The read access of the USART_DR register can be done using the USART_ReceiveData()
    529            function and returns the RDR buffered value. Whereas a write access to the USART_DR 
    530            can be done using USART_SendData() function and stores the written data into 
    531            TDR buffer.
    532          
    533          @endverbatim
    534            * @{
    535            */
    536          
    537          /**
    538            * @brief  Transmits single data through the USARTx peripheral.
    539            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    540            *         UART peripheral.
    541            * @param  Data: the data to transmit.
    542            * @retval None
    543            */
    544          void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
    545          {
    546            /* Check the parameters */
    547            assert_param(IS_USART_ALL_PERIPH(USARTx));
    548            assert_param(IS_USART_DATA(Data)); 
    549              
    550            /* Transmit Data */
    551            USARTx->DR = (Data & (uint16_t)0x01FF);
    552          }
    553          
    554          /**
    555            * @brief  Returns the most recent received data by the USARTx peripheral.
    556            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    557            *         UART peripheral.
    558            * @retval The received data.
    559            */
    560          uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
    561          {
    562            /* Check the parameters */
    563            assert_param(IS_USART_ALL_PERIPH(USARTx));
    564            
    565            /* Receive Data */
    566            return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
    567          }
    568          
    569          /**
    570            * @}
    571            */
    572          
    573          /** @defgroup USART_Group3 MultiProcessor Communication functions
    574           *  @brief   Multi-Processor Communication functions 
    575           *
    576          @verbatim   
    577           ===============================================================================
    578                              Multi-Processor Communication functions
    579           ===============================================================================  
    580          
    581            This subsection provides a set of functions allowing to manage the USART 
    582            multiprocessor communication.
    583            
    584            For instance one of the USARTs can be the master, its TX output is connected to 
    585            the RX input of the other USART. The others are slaves, their respective TX outputs 
    586            are logically ANDed together and connected to the RX input of the master.
    587          
    588            USART multiprocessor communication is possible through the following procedure:
    589               1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
    590                  or Mode receiver and hardware flow control values using the USART_Init()
    591                  function.
    592               2. Configures the USART address using the USART_SetAddress() function.
    593               3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    594                  using USART_WakeUpConfig() function only for the slaves.
    595               4. Enable the USART using the USART_Cmd() function.
    596               5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    597          
    598            The USART Slave exit from mute mode when receive the wake up condition.
    599          
    600          @endverbatim
    601            * @{
    602            */
    603          
    604          /**
    605            * @brief  Sets the address of the USART node.
    606            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    607            *         UART peripheral.
    608            * @param  USART_Address: Indicates the address of the USART node.
    609            * @retval None
    610            */
    611          void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
    612          {
    613            /* Check the parameters */
    614            assert_param(IS_USART_ALL_PERIPH(USARTx));
    615            assert_param(IS_USART_ADDRESS(USART_Address)); 
    616              
    617            /* Clear the USART address */
    618            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
    619            /* Set the USART address node */
    620            USARTx->CR2 |= USART_Address;
    621          }
    622          
    623          /**
    624            * @brief  Determines if the USART is in mute mode or not.
    625            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    626            *         UART peripheral.
    627            * @param  NewState: new state of the USART mute mode.
    628            *          This parameter can be: ENABLE or DISABLE.
    629            * @retval None
    630            */
    631          void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    632          {
    633            /* Check the parameters */
    634            assert_param(IS_USART_ALL_PERIPH(USARTx));
    635            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    636            
    637            if (NewState != DISABLE)
    638            {
    639              /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    640              USARTx->CR1 |= USART_CR1_RWU;
    641            }
    642            else
    643            {
    644              /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    645              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
    646            }
    647          }
    648          /**
    649            * @brief  Selects the USART WakeUp method.
    650            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    651            *         UART peripheral.
    652            * @param  USART_WakeUp: specifies the USART wakeup method.
    653            *          This parameter can be one of the following values:
    654            *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    655            *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    656            * @retval None
    657            */
    658          void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
    659          {
    660            /* Check the parameters */
    661            assert_param(IS_USART_ALL_PERIPH(USARTx));
    662            assert_param(IS_USART_WAKEUP(USART_WakeUp));
    663            
    664            USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
    665            USARTx->CR1 |= USART_WakeUp;
    666          }
    667          
    668          /**
    669            * @}
    670            */
    671          
    672          /** @defgroup USART_Group4 LIN mode functions
    673           *  @brief   LIN mode functions 
    674           *
    675          @verbatim   
    676           ===============================================================================
    677                                          LIN mode functions
    678           ===============================================================================  
    679          
    680            This subsection provides a set of functions allowing to manage the USART LIN 
    681            Mode communication.
    682            
    683            In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
    684            the LIN standard.
    685          
    686            Only this LIN Feature is supported by the USART IP:
    687              - LIN Master Synchronous Break send capability and LIN slave break detection
    688                capability :  13-bit break generation and 10/11 bit break detection
    689          
    690          
    691            USART LIN Master transmitter communication is possible through the following procedure:
    692               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    693                  Mode transmitter or Mode receiver and hardware flow control values using 
    694                  the USART_Init() function.
    695               2. Enable the USART using the USART_Cmd() function.
    696               3. Enable the LIN mode using the USART_LINCmd() function.
    697               4. Send the break character using USART_SendBreak() function.
    698          
    699            USART LIN Master receiver communication is possible through the following procedure:
    700               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    701                  Mode transmitter or Mode receiver and hardware flow control values using 
    702                  the USART_Init() function.
    703               2. Enable the USART using the USART_Cmd() function.
    704               3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
    705                  function.
    706               4. Enable the LIN mode using the USART_LINCmd() function.
    707          
    708          
    709          @note In LIN mode, the following bits must be kept cleared:
    710                  - CLKEN in the USART_CR2 register,
    711                  - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
    712          
    713          @endverbatim
    714            * @{
    715            */
    716          
    717          /**
    718            * @brief  Sets the USART LIN Break detection length.
    719            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    720            *         UART peripheral.
    721            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    722            *          This parameter can be one of the following values:
    723            *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    724            *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    725            * @retval None
    726            */
    727          void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
    728          {
    729            /* Check the parameters */
    730            assert_param(IS_USART_ALL_PERIPH(USARTx));
    731            assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
    732            
    733            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
    734            USARTx->CR2 |= USART_LINBreakDetectLength;  
    735          }
    736          
    737          /**
    738            * @brief  Enables or disables the USART's LIN mode.
    739            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    740            *         UART peripheral.
    741            * @param  NewState: new state of the USART LIN mode.
    742            *          This parameter can be: ENABLE or DISABLE.
    743            * @retval None
    744            */
    745          void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    746          {
    747            /* Check the parameters */
    748            assert_param(IS_USART_ALL_PERIPH(USARTx));
    749            assert_param(IS_FUNCTIONAL_STATE(NewState));
    750            
    751            if (NewState != DISABLE)
    752            {
    753              /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    754              USARTx->CR2 |= USART_CR2_LINEN;
    755            }
    756            else
    757            {
    758              /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    759              USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
    760            }
    761          }
    762          
    763          /**
    764            * @brief  Transmits break characters.
    765            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    766            *         UART peripheral.
    767            * @retval None
    768            */
    769          void USART_SendBreak(USART_TypeDef* USARTx)
    770          {
    771            /* Check the parameters */
    772            assert_param(IS_USART_ALL_PERIPH(USARTx));
    773            
    774            /* Send break characters */
    775            USARTx->CR1 |= USART_CR1_SBK;
    776          }
    777          
    778          /**
    779            * @}
    780            */
    781          
    782          /** @defgroup USART_Group5 Halfduplex mode function
    783           *  @brief   Half-duplex mode function 
    784           *
    785          @verbatim   
    786           ===============================================================================
    787                                   Half-duplex mode function
    788           ===============================================================================  
    789          
    790            This subsection provides a set of functions allowing to manage the USART 
    791            Half-duplex communication.
    792            
    793            The USART can be configured to follow a single-wire half-duplex protocol where 
    794            the TX and RX lines are internally connected.
    795          
    796            USART Half duplex communication is possible through the following procedure:
    797               1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    798                  or Mode receiver and hardware flow control values using the USART_Init()
    799                  function.
    800               2. Configures the USART address using the USART_SetAddress() function.
    801               3. Enable the USART using the USART_Cmd() function.
    802               4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
    803          
    804          
    805          @note The RX pin is no longer used
    806          @note In Half-duplex mode the following bits must be kept cleared:
    807                  - LINEN and CLKEN bits in the USART_CR2 register.
    808                  - SCEN and IREN bits in the USART_CR3 register.
    809          
    810          @endverbatim
    811            * @{
    812            */
    813          
    814          /**
    815            * @brief  Enables or disables the USART's Half Duplex communication.
    816            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    817            *         UART peripheral.
    818            * @param  NewState: new state of the USART Communication.
    819            *          This parameter can be: ENABLE or DISABLE.
    820            * @retval None
    821            */
    822          void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    823          {
    824            /* Check the parameters */
    825            assert_param(IS_USART_ALL_PERIPH(USARTx));
    826            assert_param(IS_FUNCTIONAL_STATE(NewState));
    827            
    828            if (NewState != DISABLE)
    829            {
    830              /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    831              USARTx->CR3 |= USART_CR3_HDSEL;
    832            }
    833            else
    834            {
    835              /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    836              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
    837            }
    838          }
    839          
    840          /**
    841            * @}
    842            */
    843          
    844          
    845          /** @defgroup USART_Group6 Smartcard mode functions
    846           *  @brief   Smartcard mode functions 
    847           *
    848          @verbatim   
    849           ===============================================================================
    850                                         Smartcard mode functions
    851           ===============================================================================  
    852          
    853            This subsection provides a set of functions allowing to manage the USART 
    854            Smartcard communication.
    855            
    856            The Smartcard interface is designed to support asynchronous protocol Smartcards as
    857            defined in the ISO 7816-3 standard.
    858          
    859            The USART can provide a clock to the smartcard through the SCLK output.
    860            In smartcard mode, SCLK is not associated to the communication but is simply derived 
    861            from the internal peripheral input clock through a 5-bit prescaler.
    862          
    863            Smartcard communication is possible through the following procedure:
    864               1. Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
    865               2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    866               3. Program the USART clock using the USART_ClockInit() function as following:
    867                  - USART Clock enabled
    868                  - USART CPOL Low
    869                  - USART CPHA on first edge
    870                  - USART Last Bit Clock Enabled
    871               4. Program the Smartcard interface using the USART_Init() function as following:
    872                  - Word Length = 9 Bits
    873                  - 1.5 Stop Bit
    874                  - Even parity
    875                  - BaudRate = 12096 baud
    876                  - Hardware flow control disabled (RTS and CTS signals)
    877                  - Tx and Rx enabled
    878               5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
    879                  function
    880               6. Enable the USART using the USART_Cmd() function.
    881               7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    882               8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
    883          
    884            Please refer to the ISO 7816-3 specification for more details.
    885          
    886          
    887          @note It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    888                to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    889                between the two configurations.
    890          @note In smartcard mode, the following bits must be kept cleared:
    891                  - LINEN bit in the USART_CR2 register.
    892                  - HDSEL and IREN bits in the USART_CR3 register.
    893          @note Smartcard mode is available on USART peripherals only (not available on UART4 
    894                and UART5 peripherals).
    895          
    896          @endverbatim
    897            * @{
    898            */
    899          
    900          /**
    901            * @brief  Sets the specified USART guard time.
    902            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    903            *         UART peripheral.
    904            * @param  USART_GuardTime: specifies the guard time.   
    905            * @retval None
    906            */
    907          void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
    908          {    
    909            /* Check the parameters */
    910            assert_param(IS_USART_1236_PERIPH(USARTx));
    911            
    912            /* Clear the USART Guard time */
    913            USARTx->GTPR &= USART_GTPR_PSC;
    914            /* Set the USART guard time */
    915            USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
    916          }
    917          
    918          /**
    919            * @brief  Enables or disables the USART's Smart Card mode.
    920            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    921            *         UART peripheral.
    922            * @param  NewState: new state of the Smart Card mode.
    923            *          This parameter can be: ENABLE or DISABLE.      
    924            * @retval None
    925            */
    926          void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    927          {
    928            /* Check the parameters */
    929            assert_param(IS_USART_1236_PERIPH(USARTx));
    930            assert_param(IS_FUNCTIONAL_STATE(NewState));
    931            if (NewState != DISABLE)
    932            {
    933              /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    934              USARTx->CR3 |= USART_CR3_SCEN;
    935            }
    936            else
    937            {
    938              /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    939              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
    940            }
    941          }
    942          
    943          /**
    944            * @brief  Enables or disables NACK transmission.
    945            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    946            *         UART peripheral.
    947            * @param  NewState: new state of the NACK transmission.
    948            *          This parameter can be: ENABLE or DISABLE.  
    949            * @retval None
    950            */
    951          void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    952          {
    953            /* Check the parameters */
    954            assert_param(IS_USART_1236_PERIPH(USARTx)); 
    955            assert_param(IS_FUNCTIONAL_STATE(NewState));
    956            if (NewState != DISABLE)
    957            {
    958              /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    959              USARTx->CR3 |= USART_CR3_NACK;
    960            }
    961            else
    962            {
    963              /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    964              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
    965            }
    966          }
    967          
    968          /**
    969            * @}
    970            */
    971          
    972          /** @defgroup USART_Group7 IrDA mode functions
    973           *  @brief   IrDA mode functions 
    974           *
    975          @verbatim   
    976           ===============================================================================
    977                                          IrDA mode functions
    978           ===============================================================================  
    979          
    980            This subsection provides a set of functions allowing to manage the USART 
    981            IrDA communication.
    982            
    983            IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    984            on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    985            is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    986            While receiving data, transmission should be avoided as the data to be transmitted
    987            could be corrupted.
    988          
    989            IrDA communication is possible through the following procedure:
    990               1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
    991                  modes and hardware flow control values using the USART_Init() function.
    992               2. Enable the USART using the USART_Cmd() function.
    993               3. Configures the IrDA pulse width by configuring the prescaler using  
    994                  the USART_SetPrescaler() function.
    995               4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
    996                  using the USART_IrDAConfig() function.
    997               5. Enable the IrDA using the USART_IrDACmd() function.
    998          
    999          @note A pulse of width less than two and greater than one PSC period(s) may or may
   1000                not be rejected.
   1001          @note The receiver set up time should be managed by software. The IrDA physical layer
   1002                specification specifies a minimum of 10 ms delay between transmission and 
   1003                reception (IrDA is a half duplex protocol).
   1004          @note In IrDA mode, the following bits must be kept cleared:
   1005                  - LINEN, STOP and CLKEN bits in the USART_CR2 register.
   1006                  - SCEN and HDSEL bits in the USART_CR3 register.
   1007          
   1008          @endverbatim
   1009            * @{
   1010            */
   1011          
   1012          /**
   1013            * @brief  Configures the USART's IrDA interface.
   1014            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1015            *         UART peripheral.
   1016            * @param  USART_IrDAMode: specifies the IrDA mode.
   1017            *          This parameter can be one of the following values:
   1018            *            @arg USART_IrDAMode_LowPower
   1019            *            @arg USART_IrDAMode_Normal
   1020            * @retval None
   1021            */
   1022          void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
   1023          {
   1024            /* Check the parameters */
   1025            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1026            assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
   1027              
   1028            USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
   1029            USARTx->CR3 |= USART_IrDAMode;
   1030          }
   1031          
   1032          /**
   1033            * @brief  Enables or disables the USART's IrDA interface.
   1034            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1035            *         UART peripheral.
   1036            * @param  NewState: new state of the IrDA mode.
   1037            *          This parameter can be: ENABLE or DISABLE.
   1038            * @retval None
   1039            */
   1040          void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
   1041          {
   1042            /* Check the parameters */
   1043            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1044            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1045              
   1046            if (NewState != DISABLE)
   1047            {
   1048              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
   1049              USARTx->CR3 |= USART_CR3_IREN;
   1050            }
   1051            else
   1052            {
   1053              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
   1054              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
   1055            }
   1056          }
   1057          
   1058          /**
   1059            * @}
   1060            */
   1061          
   1062          /** @defgroup USART_Group8 DMA transfers management functions
   1063           *  @brief   DMA transfers management functions
   1064           *
   1065          @verbatim   
   1066           ===============================================================================
   1067                                DMA transfers management functions
   1068           ===============================================================================  
   1069          
   1070          @endverbatim
   1071            * @{
   1072            */
   1073            
   1074          /**
   1075            * @brief  Enables or disables the USART's DMA interface.
   1076            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1077            *         UART peripheral.
   1078            * @param  USART_DMAReq: specifies the DMA request.
   1079            *          This parameter can be any combination of the following values:
   1080            *            @arg USART_DMAReq_Tx: USART DMA transmit request
   1081            *            @arg USART_DMAReq_Rx: USART DMA receive request
   1082            * @param  NewState: new state of the DMA Request sources.
   1083            *          This parameter can be: ENABLE or DISABLE.   
   1084            * @retval None
   1085            */
   1086          void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
   1087          {
   1088            /* Check the parameters */
   1089            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1090            assert_param(IS_USART_DMAREQ(USART_DMAReq));  
   1091            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
   1092          
   1093            if (NewState != DISABLE)
   1094            {
   1095              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
   1096                 DMAR bits in the USART CR3 register */
   1097              USARTx->CR3 |= USART_DMAReq;
   1098            }
   1099            else
   1100            {
   1101              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
   1102                 DMAR bits in the USART CR3 register */
   1103              USARTx->CR3 &= (uint16_t)~USART_DMAReq;
   1104            }
   1105          }
   1106          
   1107          /**
   1108            * @}
   1109            */
   1110            
   1111          /** @defgroup USART_Group9 Interrupts and flags management functions
   1112           *  @brief   Interrupts and flags management functions 
   1113           *
   1114          @verbatim   
   1115           ===============================================================================
   1116                             Interrupts and flags management functions
   1117           ===============================================================================  
   1118          
   1119            This subsection provides a set of functions allowing to configure the USART 
   1120            Interrupts sources, DMA channels requests and check or clear the flags or 
   1121            pending bits status.
   1122            The user should identify which mode will be used in his application to manage 
   1123            the communication: Polling mode, Interrupt mode or DMA mode. 
   1124              
   1125            Polling Mode
   1126            =============
   1127            In Polling Mode, the SPI communication can be managed by 10 flags:
   1128               1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
   1129               2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
   1130               3. USART_FLAG_TC : to indicate the status of the transmit operation
   1131               4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
   1132               5. USART_FLAG_CTS : to indicate the status of the nCTS input
   1133               6. USART_FLAG_LBD : to indicate the status of the LIN break detection
   1134               7. USART_FLAG_NE : to indicate if a noise error occur
   1135               8. USART_FLAG_FE : to indicate if a frame error occur
   1136               9. USART_FLAG_PE : to indicate if a parity error occur
   1137               10. USART_FLAG_ORE : to indicate if an Overrun error occur
   1138          
   1139            In this Mode it is advised to use the following functions:
   1140                - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1141                - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1142          
   1143            Interrupt Mode
   1144            ===============
   1145            In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
   1146            and 10 pending bits: 
   1147          
   1148            Pending Bits:
   1149            ------------- 
   1150               1. USART_IT_TXE : to indicate the status of the transmit buffer register
   1151               2. USART_IT_RXNE : to indicate the status of the receive buffer register
   1152               3. USART_IT_TC : to indicate the status of the transmit operation
   1153               4. USART_IT_IDLE : to indicate the status of the Idle Line             
   1154               5. USART_IT_CTS : to indicate the status of the nCTS input
   1155               6. USART_IT_LBD : to indicate the status of the LIN break detection
   1156               7. USART_IT_NE : to indicate if a noise error occur
   1157               8. USART_IT_FE : to indicate if a frame error occur
   1158               9. USART_IT_PE : to indicate if a parity error occur
   1159               10. USART_IT_ORE : to indicate if an Overrun error occur
   1160          
   1161            Interrupt Source:
   1162            -----------------
   1163               1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
   1164                                 interrupt. 
   1165               2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1166                                  empty interrupt.
   1167               3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
   1168                                 interrupt. 
   1169               4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
   1170               5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
   1171               6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
   1172                                 interrupt. 
   1173               7. USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
   1174               8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
   1175          
   1176          @note Some parameters are coded in order to use them as interrupt source or as pending bits.
   1177          
   1178            In this Mode it is advised to use the following functions:
   1179               - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
   1180               - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
   1181               - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
   1182          
   1183            DMA Mode
   1184            ========
   1185            In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
   1186               1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1187               2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1188          
   1189            In this Mode it is advised to use the following function:
   1190               - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
   1191          
   1192          @endverbatim
   1193            * @{
   1194            */
   1195          
   1196          /**
   1197            * @brief  Enables or disables the specified USART interrupts.
   1198            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1199            *         UART peripheral.
   1200            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
   1201            *          This parameter can be one of the following values:
   1202            *            @arg USART_IT_CTS:  CTS change interrupt
   1203            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1204            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1205            *            @arg USART_IT_TC:   Transmission complete interrupt
   1206            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1207            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1208            *            @arg USART_IT_PE:   Parity Error interrupt
   1209            *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
   1210            * @param  NewState: new state of the specified USARTx interrupts.
   1211            *          This parameter can be: ENABLE or DISABLE.
   1212            * @retval None
   1213            */
   1214          void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
   1215          {
   1216            uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
   1217            uint32_t usartxbase = 0x00;
   1218            /* Check the parameters */
   1219            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1220            assert_param(IS_USART_CONFIG_IT(USART_IT));
   1221            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1222          
   1223            /* The CTS interrupt is not available for UART4 and UART5 */
   1224            if (USART_IT == USART_IT_CTS)
   1225            {
   1226              assert_param(IS_USART_1236_PERIPH(USARTx));
   1227            } 
   1228              
   1229            usartxbase = (uint32_t)USARTx;
   1230          
   1231            /* Get the USART register index */
   1232            usartreg = (((uint8_t)USART_IT) >> 0x05);
   1233          
   1234            /* Get the interrupt position */
   1235            itpos = USART_IT & IT_MASK;
   1236            itmask = (((uint32_t)0x01) << itpos);
   1237              
   1238            if (usartreg == 0x01) /* The IT is in CR1 register */
   1239            {
   1240              usartxbase += 0x0C;
   1241            }
   1242            else if (usartreg == 0x02) /* The IT is in CR2 register */
   1243            {
   1244              usartxbase += 0x10;
   1245            }
   1246            else /* The IT is in CR3 register */
   1247            {
   1248              usartxbase += 0x14; 
   1249            }
   1250            if (NewState != DISABLE)
   1251            {
   1252              *(__IO uint32_t*)usartxbase  |= itmask;
   1253            }
   1254            else
   1255            {
   1256              *(__IO uint32_t*)usartxbase &= ~itmask;
   1257            }
   1258          }
   1259          
   1260          /**
   1261            * @brief  Checks whether the specified USART flag is set or not.
   1262            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1263            *         UART peripheral.
   1264            * @param  USART_FLAG: specifies the flag to check.
   1265            *          This parameter can be one of the following values:
   1266            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
   1267            *            @arg USART_FLAG_LBD:  LIN Break detection flag
   1268            *            @arg USART_FLAG_TXE:  Transmit data register empty flag
   1269            *            @arg USART_FLAG_TC:   Transmission Complete flag
   1270            *            @arg USART_FLAG_RXNE: Receive data register not empty flag
   1271            *            @arg USART_FLAG_IDLE: Idle Line detection flag
   1272            *            @arg USART_FLAG_ORE:  OverRun Error flag
   1273            *            @arg USART_FLAG_NE:   Noise Error flag
   1274            *            @arg USART_FLAG_FE:   Framing Error flag
   1275            *            @arg USART_FLAG_PE:   Parity Error flag
   1276            * @retval The new state of USART_FLAG (SET or RESET).
   1277            */
   1278          FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1279          {
   1280            FlagStatus bitstatus = RESET;
   1281            /* Check the parameters */
   1282            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1283            assert_param(IS_USART_FLAG(USART_FLAG));
   1284          
   1285            /* The CTS flag is not available for UART4 and UART5 */
   1286            if (USART_FLAG == USART_FLAG_CTS)
   1287            {
   1288              assert_param(IS_USART_1236_PERIPH(USARTx));
   1289            } 
   1290              
   1291            if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
   1292            {
   1293              bitstatus = SET;
   1294            }
   1295            else
   1296            {
   1297              bitstatus = RESET;
   1298            }
   1299            return bitstatus;
   1300          }
   1301          
   1302          /**
   1303            * @brief  Clears the USARTx's pending flags.
   1304            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1305            *         UART peripheral.
   1306            * @param  USART_FLAG: specifies the flag to clear.
   1307            *          This parameter can be any combination of the following values:
   1308            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
   1309            *            @arg USART_FLAG_LBD:  LIN Break detection flag.
   1310            *            @arg USART_FLAG_TC:   Transmission Complete flag.
   1311            *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1312            *   
   1313            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1314            *          error) and IDLE (Idle line detected) flags are cleared by software 
   1315            *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
   1316            *          followed by a read operation to USART_DR register (USART_ReceiveData()).
   1317            * @note   RXNE flag can be also cleared by a read to the USART_DR register 
   1318            *          (USART_ReceiveData()).
   1319            * @note   TC flag can be also cleared by software sequence: a read operation to 
   1320            *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
   1321            *          to USART_DR register (USART_SendData()).
   1322            * @note   TXE flag is cleared only by a write to the USART_DR register 
   1323            *          (USART_SendData()).
   1324            *   
   1325            * @retval None
   1326            */
   1327          void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1328          {
   1329            /* Check the parameters */
   1330            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1331            assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
   1332          
   1333            /* The CTS flag is not available for UART4 and UART5 */
   1334            if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
   1335            {
   1336              assert_param(IS_USART_1236_PERIPH(USARTx));
   1337            } 
   1338                 
   1339            USARTx->SR = (uint16_t)~USART_FLAG;
   1340          }
   1341          
   1342          /**
   1343            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1344            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1345            *         UART peripheral.
   1346            * @param  USART_IT: specifies the USART interrupt source to check.
   1347            *          This parameter can be one of the following values:
   1348            *            @arg USART_IT_CTS    : CTS change interrupt (not available for UART4 and UART5)
   1349            *            @arg USART_IT_LBD    : LIN Break detection interrupt
   1350            *            @arg USART_IT_TXE    : Transmit Data Register empty interrupt
   1351            *            @arg USART_IT_TC     : Transmission complete interrupt
   1352            *            @arg USART_IT_RXNE   : Receive Data register not empty interrupt
   1353            *            @arg USART_IT_IDLE   : Idle line detection interrupt
   1354            *            @arg USART_IT_ORE_RX : OverRun Error interrupt if the RXNEIE bit is set
   1355            *            @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set  
   1356            *            @arg USART_IT_NE     : Noise Error interrupt
   1357            *            @arg USART_IT_FE     : Framing Error interrupt
   1358            *            @arg USART_IT_PE     : Parity Error interrupt
   1359            * @retval The new state of USART_IT (SET or RESET).
   1360            */
   1361          ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
   1362          {
   1363            uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
   1364            ITStatus bitstatus = RESET;
   1365            /* Check the parameters */
   1366            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1367            assert_param(IS_USART_GET_IT(USART_IT)); 
   1368          
   1369            /* The CTS interrupt is not available for UART4 and UART5 */ 
   1370            if (USART_IT == USART_IT_CTS)
   1371            {
   1372              assert_param(IS_USART_1236_PERIPH(USARTx));
   1373            } 
   1374              
   1375            /* Get the USART register index */
   1376            usartreg = (((uint8_t)USART_IT) >> 0x05);
   1377            /* Get the interrupt position */
   1378            itmask = USART_IT & IT_MASK;
   1379            itmask = (uint32_t)0x01 << itmask;
   1380            
   1381            if (usartreg == 0x01) /* The IT  is in CR1 register */
   1382            {
   1383              itmask &= USARTx->CR1;
   1384            }
   1385            else if (usartreg == 0x02) /* The IT  is in CR2 register */
   1386            {
   1387              itmask &= USARTx->CR2;
   1388            }
   1389            else /* The IT  is in CR3 register */
   1390            {
   1391              itmask &= USARTx->CR3;
   1392            }
   1393            
   1394            bitpos = USART_IT >> 0x08;
   1395            bitpos = (uint32_t)0x01 << bitpos;
   1396            bitpos &= USARTx->SR;
   1397            if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
   1398            {
   1399              bitstatus = SET;
   1400            }
   1401            else
   1402            {
   1403              bitstatus = RESET;
   1404            }
   1405            
   1406            return bitstatus;  
   1407          }
   1408          
   1409          /**
   1410            * @brief  Clears the USARTx's interrupt pending bits.
   1411            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1412            *         UART peripheral.
   1413            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1414            *          This parameter can be one of the following values:
   1415            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1416            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1417            *            @arg USART_IT_TC:   Transmission complete interrupt. 
   1418            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1419            *
   1420            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1421            *          error) and IDLE (Idle line detected) pending bits are cleared by 
   1422            *          software sequence: a read operation to USART_SR register 
   1423            *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1424            *          (USART_ReceiveData()).
   1425            * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
   1426            *          (USART_ReceiveData()).
   1427            * @note   TC pending bit can be also cleared by software sequence: a read 
   1428            *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1429            *          operation to USART_DR register (USART_SendData()).
   1430            * @note   TXE pending bit is cleared only by a write to the USART_DR register 
   1431            *          (USART_SendData()).
   1432            *  
   1433            * @retval None
   1434            */
   1435          void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
   1436          {
   1437            uint16_t bitpos = 0x00, itmask = 0x00;
   1438            /* Check the parameters */
   1439            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1440            assert_param(IS_USART_CLEAR_IT(USART_IT)); 
   1441          
   1442            /* The CTS interrupt is not available for UART4 and UART5 */
   1443            if (USART_IT == USART_IT_CTS)
   1444            {
   1445              assert_param(IS_USART_1236_PERIPH(USARTx));
   1446            } 
   1447              
   1448            bitpos = USART_IT >> 0x08;
   1449            itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
   1450            USARTx->SR = (uint16_t)~itmask;
   1451          }
   1452          
   1453          /**
   1454            * @}
   1455            */
   1456          
   1457          /**
   1458            * @}
   1459            */
   1460          
   1461          /**
   1462            * @}
   1463            */
   1464          
   1465          /**
   1466            * @}
   1467            */
   1468          
   1469          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  USART_ClearFlag
             16 -> assert_failed
       16  USART_ClearITPendingBit
             16 -> assert_failed
       16  USART_ClockInit
             16 -> assert_failed
        0  USART_ClockStructInit
       16  USART_Cmd
             16 -> assert_failed
       16  USART_DMACmd
             16 -> assert_failed
        8  USART_DeInit
              0 -> RCC_APB1PeriphResetCmd
              8 -> RCC_APB1PeriphResetCmd
              0 -> RCC_APB2PeriphResetCmd
              8 -> RCC_APB2PeriphResetCmd
              0 -> assert_failed
       24  USART_GetFlagStatus
             24 -> assert_failed
       24  USART_GetITStatus
             24 -> assert_failed
       16  USART_HalfDuplexCmd
             16 -> assert_failed
       24  USART_ITConfig
             24 -> assert_failed
       32  USART_Init
             32 -> RCC_GetClocksFreq
             32 -> assert_failed
       16  USART_IrDACmd
             16 -> assert_failed
       16  USART_IrDAConfig
             16 -> assert_failed
       16  USART_LINBreakDetectLengthConfig
             16 -> assert_failed
       16  USART_LINCmd
             16 -> assert_failed
       16  USART_OneBitMethodCmd
             16 -> assert_failed
       16  USART_OverSampling8Cmd
             16 -> assert_failed
        8  USART_ReceiveData
              8 -> assert_failed
       16  USART_ReceiverWakeUpCmd
             16 -> assert_failed
        8  USART_SendBreak
              8 -> assert_failed
       16  USART_SendData
             16 -> assert_failed
       16  USART_SetAddress
             16 -> assert_failed
       16  USART_SetGuardTime
             16 -> assert_failed
       16  USART_SetPrescaler
             16 -> assert_failed
       16  USART_SmartCardCmd
             16 -> assert_failed
       16  USART_SmartCardNACKCmd
             16 -> assert_failed
        0  USART_StructInit
       16  USART_WakeUpConfig
             16 -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      84  ?<Constant "D:\\Wk.Src\\Mango-M32F2...">
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
     120  USART_ClearFlag
     138  USART_ClearITPendingBit
     182  USART_ClockInit
      12  USART_ClockStructInit
     108  USART_Cmd
     122  USART_DMACmd
     216  USART_DeInit
     158  USART_GetFlagStatus
     236  USART_GetITStatus
      96  USART_HalfDuplexCmd
     252  USART_ITConfig
     414  USART_Init
     102  USART_IrDACmd
      96  USART_IrDAConfig
      96  USART_LINBreakDetectLengthConfig
      96  USART_LINCmd
     108  USART_OneBitMethodCmd
     106  USART_OverSampling8Cmd
      72  USART_ReceiveData
     108  USART_ReceiverWakeUpCmd
      62  USART_SendBreak
      98  USART_SendData
     104  USART_SetAddress
      62  USART_SetGuardTime
      86  USART_SetPrescaler
      84  USART_SmartCardCmd
      84  USART_SmartCardNACKCmd
      24  USART_StructInit
     104  USART_WakeUpConfig

 
 3 686 bytes in section .text
 
 3 686 bytes of CODE memory

Errors: none
Warnings: none
